"""
Update Service for Qdrant/Haystack MCP Server.

Implements atomic update operations for document content and metadata using QdrantClient.
Since Haystack doesn't have native update methods, we use QdrantClient directly.
"""
import os
from typing import Dict, List, Optional, Any
from datetime import datetime

from haystack.dataclasses.document import Document
from haystack_integrations.document_stores.qdrant import QdrantDocumentStore
from haystack.components.embedders import SentenceTransformersDocumentEmbedder
from haystack.document_stores.types import DuplicatePolicy
from qdrant_client import QdrantClient
from qdrant_client.models import PointStruct, Filter, FieldCondition, MatchValue

from deduplication_service import generate_content_fingerprint
from metadata_service import build_metadata_schema, query_by_doc_id


def _get_qdrant_client() -> QdrantClient:
    """Get QdrantClient instance using environment variables."""
    qdrant_url = os.getenv("QDRANT_URL")
    qdrant_api_key = os.getenv("QDRANT_API_KEY")
    
    if not qdrant_url or not qdrant_api_key:
        raise ValueError(
            "QDRANT_URL and QDRANT_API_KEY environment variables must be set"
        )
    
    return QdrantClient(url=qdrant_url, api_key=qdrant_api_key)


def update_document_content(
    document_store: QdrantDocumentStore,
    document_id: str,
    new_content: str,
    embedder: SentenceTransformersDocumentEmbedder,
    metadata_updates: Optional[Dict[str, Any]] = None,
    collection_name: Optional[str] = None,
    code_document_store: Optional[QdrantDocumentStore] = None
) -> Dict[str, Any]:
    """
    Update document content and optionally metadata using Haystack's native write_documents with OVERWRITE policy.
    
    Process (Haystack's recommended approach):
    1. Retrieve existing document using filter_documents by ID
    2. Modify document content and metadata
    3. Generate new embedding for updated content
    4. Write back using write_documents with DuplicatePolicy.OVERWRITE
    
    Args:
        document_store: QdrantDocumentStore instance
        document_id: Document ID (hash string - Haystack handles ID conversion)
        new_content: New document content
        embedder: Document embedder for generating new embedding
        metadata_updates: Optional metadata fields to update
        collection_name: Optional collection name (not used, kept for API consistency)
        
    Returns:
        Dictionary with update results
    """
    try:
        # Step 1: Find existing document by ID using Haystack's get_documents_by_id
        # This is the correct and efficient method for ID-based retrieval
        existing_doc = None
        target_store = document_store
        
        # Try docs collection first
        try:
            docs = document_store.get_documents_by_id([document_id])
            if docs:
                existing_doc = docs[0]
                target_store = document_store
        except Exception:
            pass
        
        # Try code collection if not found
        if not existing_doc and code_document_store:
            try:
                docs = code_document_store.get_documents_by_id([document_id])
                if docs:
                    existing_doc = docs[0]
                    target_store = code_document_store
            except Exception:
                pass
        
        if not existing_doc:
            return {
                "status": "error",
                "error": f"Document not found: {document_id}"
            }
        
        # Step 2: Prepare updated metadata
        updated_meta = dict(existing_doc.meta or {})
        
        # Generate new fingerprint for new content
        fingerprint = generate_content_fingerprint(new_content, updated_meta)
        
        # Update metadata fields
        updated_meta["hash_content"] = fingerprint["content_hash"]
        updated_meta["content_hash"] = fingerprint["content_hash"]  # Alias
        updated_meta["updated_at"] = datetime.utcnow().isoformat() + 'Z'
        
        # Apply metadata updates if provided
        if metadata_updates:
            updated_meta.update(metadata_updates)
        
        # Regenerate metadata_hash
        import json
        import hashlib
        metadata_for_hash = {k: v for k, v in updated_meta.items() 
                            if k not in ['created_at', 'updated_at', 'status', 'version']}
        metadata_json = json.dumps(metadata_for_hash, sort_keys=True, default=str)
        updated_meta["metadata_hash"] = hashlib.sha256(metadata_json.encode('utf-8')).hexdigest()
        
        # Step 3: Create updated document with new content
        updated_doc = Document(
            id=existing_doc.id,  # Keep the same ID for overwrite
            content=new_content,
            meta=updated_meta,
            embedding=existing_doc.embedding  # Will be regenerated by embedder
        )
        
        # Step 4: Generate new embedding
        embedding_result = embedder.run(documents=[updated_doc])
        updated_doc_with_embedding = embedding_result["documents"][0]
        
        # Step 5: Write back using Haystack's write_documents with OVERWRITE policy
        # This is Haystack's recommended approach for updates
        # Use the target_store (docs or code) where the document was found
        target_store.write_documents(
            [updated_doc_with_embedding],
            policy=DuplicatePolicy.OVERWRITE
        )
        
        return {
            "status": "success",
            "document_id": document_id,
            "message": "Document content updated successfully",
            "updated_fields": ["content", "hash_content", "updated_at"] + (list(metadata_updates.keys()) if metadata_updates else [])
        }
    
    except Exception as e:
        return {
            "status": "error",
            "error": str(e),
            "error_type": type(e).__name__
        }


def update_document_metadata(
    document_store: QdrantDocumentStore,
    document_id: str,
    metadata_updates: Dict[str, Any],
    collection_name: Optional[str] = None,
    code_document_store: Optional[QdrantDocumentStore] = None
) -> Dict[str, Any]:
    """
    Update only metadata fields without changing content using Haystack's native write_documents with OVERWRITE policy.
    
    Process (Haystack's recommended approach):
    1. Retrieve existing document using filter_documents (check both docs and code collections)
    2. Update metadata fields (preserve content and embedding)
    3. Write back using write_documents with DuplicatePolicy.OVERWRITE
    
    Args:
        document_store: QdrantDocumentStore instance (docs collection)
        document_id: Document ID (hash string - Haystack handles ID conversion)
        metadata_updates: Dictionary of metadata fields to update
        collection_name: Optional collection name (not used, kept for API consistency)
        code_document_store: Optional code document store to check
        
    Returns:
        Dictionary with update results
    """
    try:
        # Step 1: Find existing document by ID using Haystack's get_documents_by_id
        # This is the correct and efficient method for ID-based retrieval
        existing_doc = None
        target_store = document_store
        
        # Try docs collection first
        try:
            docs = document_store.get_documents_by_id([document_id])
            if docs:
                existing_doc = docs[0]
                target_store = document_store
        except Exception:
            pass
        
        # Try code collection if not found
        if not existing_doc and code_document_store:
            try:
                docs = code_document_store.get_documents_by_id([document_id])
                if docs:
                    existing_doc = docs[0]
                    target_store = code_document_store
            except Exception:
                pass
        
        if not existing_doc:
            return {
                "status": "error",
                "error": f"Document not found: {document_id}"
            }
        
        # Step 2: Update metadata (preserve content and embedding)
        updated_meta = dict(existing_doc.meta or {})
        updated_meta.update(metadata_updates)
        updated_meta["updated_at"] = datetime.utcnow().isoformat() + 'Z'
        
        # Regenerate metadata_hash if metadata changed
        import json
        import hashlib
        metadata_for_hash = {k: v for k, v in updated_meta.items() 
                            if k not in ['created_at', 'updated_at', 'status', 'version']}
        metadata_json = json.dumps(metadata_for_hash, sort_keys=True, default=str)
        updated_meta["metadata_hash"] = hashlib.sha256(metadata_json.encode('utf-8')).hexdigest()
        
        # Step 3: Create updated document with same content and embedding
        updated_doc = Document(
            id=existing_doc.id,  # Keep the same ID for overwrite
            content=existing_doc.content,  # Preserve content
            meta=updated_meta,
            embedding=existing_doc.embedding  # Preserve embedding (no re-embedding needed)
        )
        
        # Step 4: Write back using Haystack's write_documents with OVERWRITE policy
        # This is Haystack's recommended approach for metadata-only updates
        # Use the target_store (docs or code) where the document was found
        target_store.write_documents(
            [updated_doc],
            policy=DuplicatePolicy.OVERWRITE
        )
        
        return {
            "status": "success",
            "document_id": document_id,
            "message": "Document metadata updated successfully",
            "updated_fields": list(metadata_updates.keys())
        }
    
    except Exception as e:
        return {
            "status": "error",
            "error": str(e),
            "error_type": type(e).__name__
        }


def deprecate_version(
    document_store: QdrantDocumentStore,
    document_id: str,
    collection_name: Optional[str] = None,
    content_hash: Optional[str] = None
) -> Dict[str, Any]:
    """
    Mark a document version as deprecated using QdrantClient.set_payload() with filter.
    
    Uses filter-based approach instead of point ID to avoid ID format issues
    (Haystack generates hash string IDs, but Qdrant set_payload/overwrite_payload with points
    expects integer/UUID).
    
    Strategy: Use set_payload with a filter that uniquely identifies the point by its 
    content_hash (which is unique per version). If content_hash is not provided, attempts
    to retrieve it using scroll (avoiding ID-based retrieval).
    
    Args:
        document_store: QdrantDocumentStore instance
        document_id: Document ID (Qdrant point ID - can be hash string, used for logging only)
        collection_name: Optional collection name (defaults to document_store's collection)
        content_hash: Optional content hash to use directly (avoids ID-based retrieval)
        
    Returns:
        Dictionary with deprecation results
    """
    try:
        client = _get_qdrant_client()
        
        # Get collection name
        if not collection_name:
            collection_name = document_store.index
        
        # If content_hash not provided, try to get it using scroll (avoiding ID-based retrieve)
        if not content_hash:
            # Use scroll with a filter to find the point
            # We can't filter by point ID directly, so we'll use scroll with limit=1
            # and check if any point matches (this is a fallback, not ideal)
            # Actually, better approach: use document_store.filter_documents if we have doc_id in metadata
            # But we don't have that info here. For now, return error asking for content_hash
            return {
                "status": "error",
                "error": "Cannot deprecate: content_hash is required to avoid ID format validation. Please provide content_hash from matching_doc.meta.get('hash_content')",
                "success": False
            }
        
        # Use set_payload with Filter directly in points parameter to avoid ID format validation
        # According to Qdrant Python client API, points parameter can accept:
        # - list of IDs, OR
        # - Filter object directly, OR  
        # - FilterSelector, OR
        # - PointIdsList
        # Filter by content_hash which uniquely identifies this specific version
        from qdrant_client.models import Filter, FieldCondition, MatchValue
        
        qdrant_filter = Filter(
            must=[
                FieldCondition(
                    key="meta.hash_content",  # Full nested path
                    match=MatchValue(value=content_hash)
                )
            ]
        )
        
        # Pass Filter directly to points parameter (not points_selector)
        # This updates the payload for all points matching the filter
        # Since content_hash is unique per version, this will only match one point
        client.set_payload(
            collection_name=collection_name,
            payload={"meta": {"status": "deprecated", "updated_at": datetime.utcnow().isoformat() + 'Z'}},
            points=qdrant_filter  # Filter can be passed directly to points parameter
        )
        
        return {
            "status": "success",
            "message": "Document version deprecated successfully",
            "document_id": document_id,
            "success": True
        }
    
    except Exception as e:
        return {
            "status": "error",
            "error": str(e),
            "error_type": type(e).__name__,
            "success": False
        }


def get_version_history(
    document_store: QdrantDocumentStore,
    doc_id: str,
    category: Optional[str] = None,
    include_deprecated: bool = True
) -> List[Document]:
    """
    Retrieve version history for a document by doc_id.
    
    Args:
        document_store: QdrantDocumentStore instance
        doc_id: Logical document ID (not Qdrant point ID)
        category: Optional category filter
        include_deprecated: Whether to include deprecated versions
        
    Returns:
        List of Document objects representing all versions, sorted by version/created_at
    """
    # Query by doc_id
    status_filter = None if include_deprecated else 'active'
    documents = query_by_doc_id(document_store, doc_id, category, status=status_filter)
    
    # Sort by version or created_at
    def sort_key(doc):
        meta = doc.meta or {}
        # Try to sort by version first, then by created_at
        version = meta.get("version", "")
        created_at = meta.get("created_at", "")
        return (version, created_at)
    
    documents.sort(key=sort_key)
    
    return documents

